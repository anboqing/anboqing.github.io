<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Google Protocol Buffers 简介 | 暗时间</title>
  <meta name="author" content="安勃卿">
  
  <meta name="description" content="什么是　protocol buffers ?Protocol buffers 是一种灵活、高效的序列化结构数据的自动机制－－想想XML,但是它更小，更快，更简单。你只需要把你需要怎样结构化你的数据定义一次，你就能使用特殊生成的代码来方便的用多种语言从一系列数据流中读写你的结构化数据。你甚至不需要中断">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Google Protocol Buffers 简介"/>
  <meta property="og:site_name" content="暗时间"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-70812759-1', 'auto');
  ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cb5448498d7169c668b07c2b255d62c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">暗时间</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> Google Protocol Buffers 简介</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h2 id="什么是-protocol-buffers"><a href="#什么是-protocol-buffers" class="headerlink" title="什么是　protocol buffers ?"></a>什么是　protocol buffers ?</h2><p>Protocol buffers 是一种灵活、高效的序列化结构数据的自动机制－－想想XML,但是它更小，更快，更简单。你只需要把你需要怎样结构化你的数据定义一次，你就能使用特殊生成的代码来方便的用多种语言从一系列数据流中读写你的结构化数据。你甚至不需要中断你用”老”结构编译好的已经部署的程序来更新你的数据结构。</p>
<hr>
<h2 id="它是怎样工作的？"><a href="#它是怎样工作的？" class="headerlink" title="它是怎样工作的？"></a>它是怎样工作的？</h2><p>你在一个名为<code>.proto</code>的文件里用protocol buffer message 定义你需要序列化数据的结构。每个protocol buffer message 是一个小的信息逻辑记录，包含了一系列的<code>name-value</code>对。这里有一个简单的<code>.proto</code>例子,它定义了一个<code>person</code>的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">message Person &#123;</div><div class="line">  required string name = 1;</div><div class="line">  required int32 id = 2;</div><div class="line">  optional string email = 3;</div><div class="line"></div><div class="line">  enum PhoneType &#123;</div><div class="line">    MOBILE = 0;</div><div class="line">    HOME = 1;</div><div class="line">    WORK = 2;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  message PhoneNumber &#123;</div><div class="line">    required string number = 1;</div><div class="line">    optional PhoneType type = 2 [default = HOME];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  repeated PhoneNumber phone = 4;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就像你看到的，这条信息结构很简单—每条message type 都有一个或多个独特的属性，每个属性都有一个<code>name</code>和一个<code>value</code>类型，<code>value</code>类型可以是<code>numbers</code> ( 整数或浮点数),<code>booleans</code>,<code>strings</code>,<code>raw bytes</code>或者其他<code>protocol buffer message types</code>，允许你以嵌套结构组织你的结构。你可以指定<code>optional</code>,<code>required</code>、和<code>repeated</code>属性。你可以从<a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="external"> Protocol Buffer Language Guide</a>找到更多的关于如何写<code>.proto</code>文件的信息。</p>
<p>一旦你定义了你的信息，你就可以运行protocol buffer 编译器来编译你的.proto文件来生成特定语言的数据访问类。这些类提供了简单的对属性的访问函数（例如 <code>name()</code>和<code>set_name()</code> )和用来序列化整个结构到raw bytes和从raw bytes 解析出结构的函数。例如，假如你使用的是c++语言，用编译器编译上面那个<code>person</code>的<code>.proto</code>文件会生成一个<code>Person</code>类。你可以在你的应用里用这个类来操纵<code>Person</code>类的对象。比如，你可能会写一些这样的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Person person;</div><div class="line">person.set_name(&quot;John Doe&quot;);</div><div class="line">person.set_id(1234);</div><div class="line">person.set_email(&quot;jdoe@example.com&quot;);</div><div class="line">fstream output(&quot;myfile&quot;, ios::out | ios::binary);</div><div class="line">person.SerializeToOstream(&amp;output);</div></pre></td></tr></table></figure>
<p>然后，你可以通过这样的代码来把你的message读进来:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fstream input(&quot;myfile&quot;, ios::in | ios::binary);</div><div class="line">Person person;</div><div class="line">person.ParseFromIstream(&amp;input);</div><div class="line">cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.name() &lt;&lt; endl;</div><div class="line">cout &lt;&lt; &quot;E-mail: &quot; &lt;&lt; person.email() &lt;&lt; endl;</div></pre></td></tr></table></figure></p>
<p>你可以给你的message添加新的属性而不打破向后兼容性(backwards-compatibility);旧的二进制文件仅仅在编译的时候忽略那些新的属性。这样一来，如果你有一个通信协议使用了protocol buffers当做它传输的数据格式，你可以扩展你的通信协议而不用担心破坏现有的代码。</p>
<p>你可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/overview" target="_blank" rel="external">API Reference section</a>找到完整的文档，并且你可以在<a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="external">Protocol buffer encoding</a>找出关于protocol buffer 编码的更多信息.</p>
<hr>
<h2 id="为什么不用XML等其他技术"><a href="#为什么不用XML等其他技术" class="headerlink" title="为什么不用XML等其他技术?"></a>为什么不用XML等其他技术?</h2><p>Protocol buffers相对XML在序列化数据的时候有很多优势。protocol buffers :</p>
<ul>
<li>更简单</li>
<li>比XML小３到１０倍</li>
<li>比XML快２０到１００倍</li>
<li>更少歧义</li>
<li>可以生成方便编程的数据访问类</li>
</ul>
<p>例如，假若你要给<code>person</code>建模，它有<code>name</code>和<code>email</code>属性。在XML里，你需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;person&gt;</div><div class="line">    &lt;name&gt;John Doe&lt;/name&gt;</div><div class="line">    &lt;email&gt;jdoe@example.com&lt;/email&gt;</div><div class="line">&lt;/person&gt;</div></pre></td></tr></table></figure></p>
<p>用protocol buffer message（在protocol buffer 的text format）是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Textual representation of a protocol buffer.</div><div class="line"># This is *not* the binary format used on the wire.</div><div class="line">person &#123;</div><div class="line">  name: &quot;John Doe&quot;</div><div class="line">  email: &quot;jdoe@example.com&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面这段代码被编译成<code>binary format</code>（上面那段text format只是为了方便人类读写编辑的）的时候，它可能只占28字节长，仅仅需要100~200纳秒就能编译。那个XML版本即使移除所有空白也至少需要69字节，并且需要5000~10000纳秒来编译。</p>
<p>同样，操作protocol buffer 更容易:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.name() &lt;&lt; endl;</div><div class="line">cout &lt;&lt; &quot;E-mail:&quot; &lt;&lt; person.email() &lt;&lt; endl;</div></pre></td></tr></table></figure></p>
<p>然而如果使用XML你需要这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cout &lt;&lt; &quot;Name: &quot;</div><div class="line">       &lt;&lt; person.getElementsByTagName(&quot;name&quot;)-&gt;item(0)-&gt;innerText()</div><div class="line">       &lt;&lt; endl;</div><div class="line">cout &lt;&lt; &quot;E-mail: &quot;</div><div class="line">       &lt;&lt; person.getElementsByTagName(&quot;email&quot;)-&gt;item(0)-&gt;innerText()</div><div class="line">       &lt;&lt; endl;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="嗯～听起来能解决我的问题！我该怎样开始呢？"><a href="#嗯～听起来能解决我的问题！我该怎样开始呢？" class="headerlink" title="嗯～听起来能解决我的问题！我该怎样开始呢？"></a>嗯～听起来能解决我的问题！我该怎样开始呢？</h2><p><a href="https://developers.google.com/protocol-buffers/docs/downloads.html" target="_blank" rel="external">下载地址</a>–这个包包含了完整的c++,python和java语言的编译器源代码，和I/O和测试的类。安装请参阅README。</p>
<p>一旦你安装好了，就可以跟着<a href="https://developers.google.com/protocol-buffers/docs/tutorials" target="_blank" rel="external">入门教程</a>来学习了。</p>
<hr>
<h2 id="入门教程c-版"><a href="#入门教程c-版" class="headerlink" title="入门教程c++版"></a>入门教程c++版</h2><p>这个教程会带你走一遍使用protocol buffer的流程，创建一个简单的实例程序，学会基本的使用方法：</p>
<ul>
<li>在<code>.proto</code>文件里定义信息格式</li>
<li>使用protocol buffer编译器</li>
<li>使用c++ protocol buffer API来读写信息</li>
</ul>
<hr>
<h3 id="为什么使用protocol-buffers"><a href="#为什么使用protocol-buffers" class="headerlink" title="为什么使用protocol buffers?"></a>为什么使用protocol buffers?</h3><p>在这个教程里我们要创建一个简单的“地址簿”程序来在文件里读写人们的联系人信息。每个人都有一个name,id,email address和一个联系电话。</p>
<p>你怎样序列化和读取这样一个结构数据呢？这里有三种方法:</p>
<ul>
<li>内存中原始的字节数据结构可以存储为２进制形式。这种方法很脆弱，因为读取代码必须用同样的内存布局编译，还要考虑使用相同的内存大小端等等。当文件积累了很多数据之后，拷贝到处都是，扩展结构就很困难了。</li>
<li>你可以发明一个点对点的方式来把数据编码为一个简单的字符串—例如编码４个整数为”12:3:-23:67”.这是一个简单且灵活的方法，尽管它需要你编写一次性的读写代码，读取需要一些运行时间。这种方法适用于编码十分简单的数据。</li>
<li>序列化数据到XML文件。如果你需要和其他程序共享数据，那么这将是个好方法。然而，XML占内存已经臭名昭著了，解析编码它会造成程序性能大幅下降。在XML DOM tree里巡弋也远比在类里查找属性复杂的多。</li>
</ul>
<p>protocol buffers 灵活高效，可以解决上述问题。你只需要编写一个<code>.proto</code>文件来描述你要使用的数据结构。protocol buffer 编译器可以把<code>.proto</code>文件编译成一个类似于ORM(object relation mapping)实现类的数据访问类，这个类可以把高效的用二进制文件方式存储的数据读写出来。更多的是，它提供了一种向后兼容的扩展机制，使你可以不用担心兼容性问题来扩展你的数据格式。</p>
<hr>
<h3 id="定义你的protocol-Format"><a href="#定义你的protocol-Format" class="headerlink" title="定义你的protocol Format"></a>定义你的protocol Format</h3><p>为了创建地址簿程序，你需要首先定义一个<code>.proto</code>文件。定义<code>.proto</code>文件十分简单：　你添加一个 <code>message</code> 给你想序列化的每个数据结构　，然后指定一个 <code>name</code>和一个<code>type</code>给<code>message</code>的每个属性。下面是一个<code>.proto</code>文件，定义了地址簿数据结构,<code>addressbook.proto</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">package tutorial;</div><div class="line"></div><div class="line">message Person &#123;</div><div class="line">  required string name = 1;</div><div class="line">  required int32 id = 2;</div><div class="line">  optional string email = 3;</div><div class="line"></div><div class="line">  enum PhoneType &#123;</div><div class="line">    MOBILE = 0;</div><div class="line">    HOME = 1;</div><div class="line">    WORK = 2;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  message PhoneNumber &#123;</div><div class="line">    required string number = 1;</div><div class="line">    optional PhoneType type = 2 [default = HOME];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  repeated PhoneNumber phone = 4;</div><div class="line">&#125;</div><div class="line"></div><div class="line">message AddressBook &#123;</div><div class="line">  repeated Person person = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>protobuffer支持的内建数据类型包括<code>bool</code>,<code>int32</code>,<code>float</code>,<code>double</code>,<code>string</code>.<br>注意：message可以嵌套，比如　PhoneNumber 就定义在Person里。<br>“＝１”，“＝２”标记了每个元素的唯一“tag”,这是用在二进制编码里的。使用１－１５可以在１个字节里表示这些tag，节省空间，一般把常用的需要大量重复的元素使用1-15来编码，把１６以上的tag留给不常用的元素。</p>
<p>每个属性必须标记为下列修饰符之一：</p>
<ul>
<li><code>required</code> : 故名思议就是必须提供值的属性，当你把属性设置为required的时候要小心，因为如果以后想修改为其他类型，老的读取类就不兼容新的数据了。</li>
<li><code>optional</code>: 就是可以不提供值的属性,如果没有提供值，会设置为默认值。默认值可以自己提供，如果没有自己提供默认值，会设置为系统默认值：numeric类型会置为０，字符串置为空串，bool置为false;对于内嵌类型，默认值永远是空实例。</li>
<li><code>repeated</code>:就是可能重复任意次（包含０次).重复值的顺序会在二进制文件保存下来，可以把重复的属性看做动态大小的数组。注意，由于历史原因，<code>repeated</code>数值属性不能有效的被编码成二进制，新的代码可以使用<code>[packed=true]</code>来获得更好的编码效率<blockquote>
<p>例如：　<figure class="highlight plain"><figcaption><span>int32 samples = 4 [packed=true];```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">---</div><div class="line">### 编译你的protocol buffers文件</div><div class="line">现在你拥有一个`.proto`文件，接下来你需要生成一个读写你的`AddressBook`类的访问类。你需要用protocol buffer编译器`protoc`来编译你的`.proto`文件:</div><div class="line"></div><div class="line">&gt; ```protoc -I=\$SRC_DIR --cpp_out=\$DST_DIR \$SRC_DIR/addressbook.proto</div></pre></td></tr></table></figure></p>
</blockquote>
</li>
</ul>
<p><code>cpp_out</code>可以换成<code>python_out</code>或者<code>java_out</code>。<br>编译完成后，就会在<em>DST_DIR</em>下面生成２个文件：</p>
<ul>
<li><code>addressbook.pb.h</code></li>
<li><code>addressbook.pb.cc</code></li>
</ul>
<hr>
<h3 id="Protocol-Buffer-API"><a href="#Protocol-Buffer-API" class="headerlink" title="Protocol Buffer API"></a>Protocol Buffer API</h3><p>我们现在来看一些生成的code是什么样的，编译器为我们生成了什么类和函数呢？<br>如果我们打开<code>tutorial.pb.h</code>，我们会看到编译器给我们在<code>.proto</code>文件里定义的每一个<code>message</code>都生成了一个<strong>class</strong>，我们再看<code>Person</code>类，会发现编译器给<em>message</em>的每个属性都生成了<em>getters和setters</em>，例如，对于<code>name</code>,<code>id</code>,<code>email</code>,和<code>phone</code>属性，我们可以找到这些函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// name</div><div class="line">  inline bool has_name() const;</div><div class="line">  inline void clear_name();</div><div class="line">  inline const ::std::string&amp; name() const;</div><div class="line">  inline void set_name(const ::std::string&amp; value);</div><div class="line">  inline void set_name(const char* value);</div><div class="line">  inline ::std::string* mutable_name();</div><div class="line"></div><div class="line">  // id</div><div class="line">  inline bool has_id() const;</div><div class="line">  inline void clear_id();</div><div class="line">  inline int32_t id() const;</div><div class="line">  inline void set_id(int32_t value);</div><div class="line"></div><div class="line">  // email</div><div class="line">  inline bool has_email() const;</div><div class="line">  inline void clear_email();</div><div class="line">  inline const ::std::string&amp; email() const;</div><div class="line">  inline void set_email(const ::std::string&amp; value);</div><div class="line">  inline void set_email(const char* value);</div><div class="line">  inline ::std::string* mutable_email();</div><div class="line"></div><div class="line">  // phone</div><div class="line">  inline int phone_size() const;</div><div class="line">  inline void clear_phone();</div><div class="line">  inline const ::google::protobuf::RepeatedPtrField&lt; ::tutorial::Person_PhoneNumber &gt;&amp; phone() const;</div><div class="line">  inline ::google::protobuf::RepeatedPtrField&lt; ::tutorial::Person_PhoneNumber &gt;* mutable_phone();</div><div class="line">  inline const ::tutorial::Person_PhoneNumber&amp; phone(int index) const;</div><div class="line">  inline ::tutorial::Person_PhoneNumber* mutable_phone(int index);</div><div class="line">  inline ::tutorial::Person_PhoneNumber* add_phone();</div></pre></td></tr></table></figure>
<p>正如你所能看到的那样，getters和小写属性名一样，setters以<code>set_</code>开头。还有<code>has_</code>开头的判断是否设置了值的函数。还有<code>clear_</code>开头的函数用于清空设置的值。</p>
<p>不同类型的属性方法不尽相同，例如 <code>id</code>只有基本的getter,setter方法，而<code>name</code>,<code>email</code>等字符串类型的属性多了一个<code>mutable_</code>开头的getter,和一个多出来的setter。即使还没有设置<code>email</code>仍然可以调用<code>mutable_email</code>。它可以自动初始化为一个空字符串。</p>
<p><code>repeated</code>属性同样有些特别的方法，例如<code>phone</code>属性：</p>
<ul>
<li>可以查看<code>_size</code>（这个人有多少个电话号码)</li>
<li>可以通过<code>index</code>访问一个特定的值</li>
<li>可以添加一个新值(通过<code>add_</code>方法)</li>
</ul>
<p>更多关于编译器生成函数的信息请参看<a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated" target="_blank" rel="external">C++ generated code reference</a></p>
<hr>
<h4 id="枚举和嵌套类"><a href="#枚举和嵌套类" class="headerlink" title="枚举和嵌套类"></a>枚举和嵌套类</h4><p>生成的代码包含了一个<code>PhoneType</code>枚举对应你的<code>.proto</code>文件里的enum.你可以通过<code>Person::PhoneType</code>来使用这个枚举，和它的值<code>Person::MOBILE</code>,<code>Person::HOME</code>,<code>Person::WORK</code>(具体实现很复杂，但我们不需要了解它）</p>
<p>编译器同样生成了一个嵌套类<code>Person::PhoneNumber</code>。如果查看代码，会发现实际的类是叫做<code>Person_PhoneNumber</code>,但是使用了一个<code>typedef</code>来重命名了它，唯一的区别是当你想在另一个文件里<strong>前向声明</strong>这个类的时候，必须使用<code>Person_PhoneNumber</code>来前向声明它。</p>
<hr>
<h4 id="标准-Message方法"><a href="#标准-Message方法" class="headerlink" title="标准 Message方法"></a>标准 Message方法</h4><p>每个message类还包含了一些其他方法来使你能检查或者操作整个message,包括:</p>
<ul>
<li><code>bool IsInitialized() const</code>;: checks if all the required fields have been set.</li>
<li><code>string DebugString() const</code>;: returns a human-readable representation of the message, particularly useful for debugging.</li>
<li><code>void CopyFrom(const Person&amp; from)</code>;: overwrites the message with the given message’s values.</li>
<li><code>void Clear()</code>;: clears all the elements back to the empty state. </li>
</ul>
<hr>
<h4 id="解析和序列化"><a href="#解析和序列化" class="headerlink" title="解析和序列化"></a>解析和序列化</h4><p>最终，每个protocol buffer class使用读写方法来解析和序列化message到二进制文件里，这些方法包括:</p>
<ul>
<li><code>bool SerializeToString(string* output) const</code>;: 序列化一个message并且把字节文件存储到string里，这里使用string仅仅是为了把它当做一个方便的容器.</li>
<li><code>bool ParseFromString(const string&amp; data)</code>;: 从指定的string里解析message</li>
<li><code>bool SerializeToOstream(ostream* output) const</code>;: 把message写到指定的c++｀ostream`里。</li>
<li><code>bool ParseFromIstream(istream* input)</code>;: 从指定的c++<code>istream</code>读取message</li>
</ul>
<p>查看<a href="https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.message.html#Message" target="_blank" rel="external">Message API</a>获取更详细内容.</p>
<hr>
<h3 id="写一个Message"><a href="#写一个Message" class="headerlink" title="写一个Message"></a>写一个Message</h3><p>现在,让我们试着使用编译器为我们生成的类。我们让我们的地址簿程序做的第一件事情是把一个人的个人信息写到地址簿文件里。我们需要生成一个该类的实例然后把它写入到输出流里。</p>
<p>这里有一个实例程序:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"addressbook.pb.h"</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">// This function fills in a Person message based on user input.</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PromptForAddress</span><span class="params">(tutorial::Person* person)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter person ID number: "</span>;</div><div class="line">  <span class="keyword">int</span> id;</div><div class="line">  <span class="built_in">cin</span> &gt;&gt; id;</div><div class="line">  person-&gt;set_id(id);</div><div class="line">  <span class="built_in">cin</span>.ignore(<span class="number">256</span>, <span class="string">'\n'</span>);</div><div class="line"></div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter name: "</span>;</div><div class="line">  getline(<span class="built_in">cin</span>, *person-&gt;mutable_name());</div><div class="line"></div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter email address (blank for none): "</span>;</div><div class="line">  <span class="built_in">string</span> email;</div><div class="line">  getline(<span class="built_in">cin</span>, email);</div><div class="line">  <span class="keyword">if</span> (!email.empty()) &#123;</div><div class="line">    person-&gt;set_email(email);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a phone number (or leave blank to finish): "</span>;</div><div class="line">    <span class="built_in">string</span> number;</div><div class="line">    getline(<span class="built_in">cin</span>, number);</div><div class="line">    <span class="keyword">if</span> (number.empty()) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    tutorial::Person::PhoneNumber* phone_number = person-&gt;add_phone();</div><div class="line">    phone_number-&gt;set_number(number);</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Is this a mobile, home, or work phone? "</span>;</div><div class="line">    <span class="built_in">string</span> type;</div><div class="line">    getline(<span class="built_in">cin</span>, type);</div><div class="line">    <span class="keyword">if</span> (type == <span class="string">"mobile"</span>) &#123;</div><div class="line">      phone_number-&gt;set_type(tutorial::Person::MOBILE);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">"home"</span>) &#123;</div><div class="line">      phone_number-&gt;set_type(tutorial::Person::HOME);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">"work"</span>) &#123;</div><div class="line">      phone_number-&gt;set_type(tutorial::Person::WORK);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Unknown phone type.  Using default."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Main function:  Reads the entire address book from a file,</span></div><div class="line"><span class="comment">//   adds one person based on user input, then writes it back out to the same</span></div><div class="line"><span class="comment">//   file.</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line">  <span class="comment">// Verify that the version of the library that we linked against is</span></div><div class="line">  <span class="comment">// compatible with the version of the headers we compiled against.</span></div><div class="line">  GOOGLE_PROTOBUF_VERIFY_VERSION;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</div><div class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Usage:  "</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">" ADDRESS_BOOK_FILE"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  tutorial::AddressBook address_book;</div><div class="line"></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// Read the existing address book.</span></div><div class="line">    <span class="function">fstream <span class="title">input</span><span class="params">(argv[<span class="number">1</span>], ios::in | ios::binary)</span></span>;</div><div class="line">    <span class="keyword">if</span> (!input) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="string">": File not found.  Creating a new file."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!address_book.ParseFromIstream(&amp;input)) &#123;</div><div class="line">      <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to parse address book."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Add an address.</span></div><div class="line">  PromptForAddress(address_book.add_person());</div><div class="line"></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// Write the new address book back to disk.</span></div><div class="line">    <span class="function">fstream <span class="title">output</span><span class="params">(argv[<span class="number">1</span>], ios::out | ios::trunc | ios::binary)</span></span>;</div><div class="line">    <span class="keyword">if</span> (!address_book.SerializeToOstream(&amp;output)) &#123;</div><div class="line">      <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to write address book."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Optional:  Delete all global objects allocated by libprotobuf.</span></div><div class="line">  google::protobuf::ShutdownProtobufLibrary();</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意代码中的<code>GOOGLE_PROTOBUF_VERIFY_VERSION</code>宏,在使用c++ Protocol Buffer 之前执行这个宏是一个好的习惯（尽管不是强制要求的)。它会验证你是否链接了正确的库，防止你链接版本不匹配的库。</p>
<p>注意代码中的<code>ShutdownProtobufLibrary()</code>，它会清楚所有protocol buffer libarary分配的全局对象。通常这是不需要的，因为这个进程总是会退出，系统会接管剩下的内存。但是，如果你使用了一个内存泄露检查工具，比如<code>valgrand</code>之类的，这类工具会要求你把所有分配的内存释放掉，或者你在写一个库文件，这个库文件会被同一个进程加载和卸载多次，这两种情况你就需要清理所有东西。</p>
<hr>
<h3 id="读取一个Message"><a href="#读取一个Message" class="headerlink" title="读取一个Message"></a>读取一个Message</h3><p>这是一个从二进制文件读取地址簿的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;fstream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &quot;addressbook.pb.h&quot;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">// Iterates though all people in the AddressBook and prints info about them.</div><div class="line">void ListPeople(const tutorial::AddressBook&amp; address_book) &#123;</div><div class="line">  for (int i = 0; i &lt; address_book.person_size(); i++) &#123;</div><div class="line">    const tutorial::Person&amp; person = address_book.person(i);</div><div class="line"></div><div class="line">    cout &lt;&lt; &quot;Person ID: &quot; &lt;&lt; person.id() &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;  Name: &quot; &lt;&lt; person.name() &lt;&lt; endl;</div><div class="line">    if (person.has_email()) &#123;</div><div class="line">      cout &lt;&lt; &quot;  E-mail address: &quot; &lt;&lt; person.email() &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (int j = 0; j &lt; person.phone_size(); j++) &#123;</div><div class="line">      const tutorial::Person::PhoneNumber&amp; phone_number = person.phone(j);</div><div class="line"></div><div class="line">      switch (phone_number.type()) &#123;</div><div class="line">        case tutorial::Person::MOBILE:</div><div class="line">          cout &lt;&lt; &quot;  Mobile phone #: &quot;;</div><div class="line">          break;</div><div class="line">        case tutorial::Person::HOME:</div><div class="line">          cout &lt;&lt; &quot;  Home phone #: &quot;;</div><div class="line">          break;</div><div class="line">        case tutorial::Person::WORK:</div><div class="line">          cout &lt;&lt; &quot;  Work phone #: &quot;;</div><div class="line">          break;</div><div class="line">      &#125;</div><div class="line">      cout &lt;&lt; phone_number.number() &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Main function:  Reads the entire address book from a file and prints all</div><div class="line">//   the information inside.</div><div class="line">int main(int argc, char* argv[]) &#123;</div><div class="line">  // Verify that the version of the library that we linked against is</div><div class="line">  // compatible with the version of the headers we compiled against.</div><div class="line">  GOOGLE_PROTOBUF_VERIFY_VERSION;</div><div class="line"></div><div class="line">  if (argc != 2) &#123;</div><div class="line">    cerr &lt;&lt; &quot;Usage:  &quot; &lt;&lt; argv[0] &lt;&lt; &quot; ADDRESS_BOOK_FILE&quot; &lt;&lt; endl;</div><div class="line">    return -1;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  tutorial::AddressBook address_book;</div><div class="line"></div><div class="line">  &#123;</div><div class="line">    // Read the existing address book.</div><div class="line">    fstream input(argv[1], ios::in | ios::binary);</div><div class="line">    if (!address_book.ParseFromIstream(&amp;input)) &#123;</div><div class="line">      cerr &lt;&lt; &quot;Failed to parse address book.&quot; &lt;&lt; endl;</div><div class="line">      return -1;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ListPeople(address_book);</div><div class="line"></div><div class="line">  // Optional:  Delete all global objects allocated by libprotobuf.</div><div class="line">  google::protobuf::ShutdownProtobufLibrary();</div><div class="line"></div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="扩展一个Protocol-Buffer"><a href="#扩展一个Protocol-Buffer" class="headerlink" title="扩展一个Protocol Buffer"></a>扩展一个Protocol Buffer</h3><p>当一段时间之后你需要在你发布使用你的protocol buffer后改进你的protocol buffer定义。如果你希望你的新buffer能够向前兼容，而你的老buffer能向后兼容，那么你就需要遵守下面这几个规则：</p>
<ul>
<li><strong>不要修改</strong><code>tag</code>数字</li>
<li><strong>不要增删任何</strong><code>required</code>属性</li>
<li><strong>可以</strong>删除<code>repeated</code>或者<code>optional</code>属性</li>
<li><strong>可以添加</strong> <code>repeated</code>或者<code>optional</code>属性，但是必须使用<strong>新tag number</strong></li>
</ul>
<hr>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2016/01/10/函数式编程/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2015/12/27/为什么负梯度方向下降最快/" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>
	
	<!-- comment -->
	
<section id="comment">
    <h2 class="title">Comments</h2>

    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2016-01-10 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/caffe/">caffe<span>1</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/caffe-proto/">caffe .proto<span>1</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2016 安勃卿
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  <a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    }); 
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

</body>
   </html>
